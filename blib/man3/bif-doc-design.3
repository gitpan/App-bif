.\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "bif-doc-design 3"
.TH bif-doc-design 3 "2014-04-17" "perl v5.18.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Bif Design"
.IX Header "Bif Design"
This document attempts to describe why and how the Bif project
management tool x does what it does.
.SH "Version"
.IX Header "Version"
0.1.0_10 (2014\-04\-17)
.SH "Background"
.IX Header "Background"
The development of Distributed Version Control System (\s-1DVCS\s0) software
enabled developers to discover the joys of working with a
fully-featured, always available local repository.  A number of
benefits related to productivity (working when not connected) and
efficiency (fast executing commands) appeared.  Shortly afterwards
developers re-discovered the pain of still having to use centralised,
web-based bug/issue tracking systems, which kind of muted the joy
somewhat.
.PP
The first open attempts at a Distributed Project Management System
(\s-1DPMS\s0) such as Bugs Everywhere, ScmBug, DisTract, DITrack, ticgit and
ditz, were implemented on top of a \s-1DVCS. \s0 With a bit of hindsight, one
can theorize that their failure to gain real traction was in part due
to not understanding that \s-1DVCS\s0 and \s-1DPMS\s0 systems do not have the same
information models. With time, most projects have also realized that
there are users other than developers who need to interact with such a
tool.
.PP
Later, \s-1DPMS\s0 systems were built on different models, but offered a
non-UNIXy implementation (Fossil) or suffered documentation and
implementation issues (Simple Defects \- \s-1SD\s0). As of late 2011 the Debian
\&\s-1BTS \s0(debbugs), \s-1SD\s0 and Launchpad (Canonical) appear to be the only
systems that provide some kind of interproject cooperation (one issue
with different status), but neither debbugs nor Launchpad are really
distributed.
.PP
It was in this context that Bif was started in with the vague aim of
doing something better. While I can say I was trying to learn from
earlier efforts, I had nothing like the clarity of mind at the
beginning that the above paragraphs imply.  Like several others I
actually started out building Bif on top of Git. This is no surprise
because like everyone else I found the easy replication and plumbing
toolset attractive.  Experience finally taught me too that the Git
model was the wrong one for this application, so after briefly playing
with SQLite + Git I settled on SQLite alone with a purpose-built schema
and a completely new synchronisation protocol.
.SH "Design Goals"
.IX Header "Design Goals"
The user manual says that Bif aims to be:
.PP
.Vb 2
\&    "... a distributed communication system that carries both
\&    conversations and structured meta\-data."
.Ve
.PP
To put it another way, the goal of Bif is to provide users with a fully
functional local issue tracker that interacts with remote instances as
needed.
.SH "Requirements/Constraints"
.IX Header "Requirements/Constraints"
Note that some of the distributed requirements for a *project* tracking
system are actually quite different to the distributed requirements for
a *software* tracking system. \s-1DVCS\s0 focus on managing a multi-tentacled,
pick-from-anywhere, many-versions-at-a-time set of changes to files.
\&\s-1DPMS\s0 focus is on tracking items of work at the organisational or
personal level.
.IP "Command-line Interface (At Least)" 4
.IX Item "Command-line Interface (At Least)"
Context switching from the shell to the browser is costly. Good
engineering means that the \s-1CLI\s0 is anyway a thin layer over the
database, meaning that adding other interfaces later is relatively
easy.
.Sp
\&\s-1CLI\s0 should be consistent, semi-similar to other \s-1CLI\s0 programs.  Oh yeah,
I almost forgot. The \s-1CLI\s0 should be responsive enough to be almost
instantaneous. There will be no Moose in this \s-1CLI\s0 tool. Even though I
upgraded my laptop recently with an \s-1SSD I\s0 still can't believe how much
it affects the startup time in things like App::TimeTracker.  If I
release something like that the thoughts of the first (non-Perl-aware)
user will be \*(L"Do we need to rewrite this in Go?\*(R"
.IP "Powerful Querying" 4
.IX Item "Powerful Querying"
For management-style reports, for custom queries, for dealing with the
whole interproject cooperation requirement. Users need to quickly see
summaries of the current status as well as the change history.
.IP "Distributed/Offline Operation" 4
.IX Item "Distributed/Offline Operation"
As much as possible, the tool should work everywhere that you can. In
effect that means data replication.
.IP "Fast Delta Synchronisation" 4
.IX Item "Fast Delta Synchronisation"
There is no way that a sequential scan and check for matching rows in
databases should be done each time a user wants to synchronise.
.Sp
A RESTful object \s-1API\s0 just doesn't seem suitable either for working with
large collections of objects like bugs or projects, and how does one
not lose all the benefits associated with database transactions?
.Sp
A project history is not a hierarchical tree al-la Git trees. Updates
can be merged without needing to reparent anything.
.IP "Universally Unique Identifiers" 4
.IX Item "Universally Unique Identifiers"
Necessary for exchanging updates between systems that have their own
requirements for locally unique identifiers.
.IP "Locally Unique Integers" 4
.IX Item "Locally Unique Integers"
We cannot subject users to identifiers that look like abb382f3c.
.IP "Interproject Cooperation" 4
.IX Item "Interproject Cooperation"
If we are going to distribute things, we should do it properly. That
means an issue can be tracked by multiple projects, and that each
project could consider it to have a different status, and that each
project can see the status in the other projects.
.IP "No Universal Status" 4
.IX Item "No Universal Status"
No reason that every project in the whole Bif ecosystem must use the
same status types.
.IP "Extreme Documentation" 4
.IX Item "Extreme Documentation"
Aside from functionality, for this to be successful it has to be
useable, approachable, and understandable. In many ways this comes down
to the quality of the documentation.
.SH "Application Architecture"
.IX Header "Application Architecture"
Bif is a Perl wrapper around an SQLite database. Commands are
dispatched to Perl modules under the App::bif::* namespace by
OptArgs. Execution happens like this:
.IP "\(bu" 4
The shell runs the \f(CW\*(C`bif\*(C'\fR file, which due to the #! hashbang
line results in \f(CW\*(C`perl\*(C'\fR being executed on that file.
.IP "\(bu" 4
The \f(CW\*(C`bif\*(C'\fR script loads the Perl module OptArgs and calls
the \f(CW\*(C`OptArgs::dispatch\*(C'\fR function against the App::bif namespace.
.IP "\(bu" 4
App::bif defines all of the subcommands, their arguments and
options, which the dispatch function uses to dispatch to the
appropriate App::bif::* module.
.IP "\(bu" 4
The App::bif::sub::command module \f(CW\*(C`run\*(C'\fR method is called.
.IP "\(bu" 4
Sub-command classes use functions from App::bif::Context to
discover the location of the repository, the user configuration, access
the database, render output, generate errors and so on.
.IP "\(bu" 4
the program ends.
.SS "Database access"
.IX Subsection "Database access"
Each command uses either Bif::DB or Bif::DB::RW (based on
DBIx::ThinSQL, \s-1DBI\s0, and DBD::SQLite) to access the database.
.PP
As much as possible is done inside the database with the goal of
ensuring data consistency regardless of what application is entering
the data. Preparing for some other tool than Bif to be making
modifications.
.SS "Fake SQLite function calls"
.IX Subsection "Fake SQLite function calls"
SQLite does not have a built-in procedural programming language with a
function calling interface. We cheat by defining \f(CW\*(C`BEFORE INSERT\*(C'\fR
triggers on normal tables that do their required work and then cancel
the insert with a \f(CW\*(C`SELECT RAISE(IGNORE)\*(C'\fR statement.
.SS "Transport & Synchronisation"
.IX Subsection "Transport & Synchronisation"
Bif uses ssh to run the bifsync program on remote hosts when
exchanging updates with a hub, or else calls bifsync directly when
exchanging updates with a local repository. Regardless, it ends up
being Bif::Client that is talking to Bif::Server, although most
of the functionality is in the parent Bif::Role::Sync class.
.PP
Client/Server is a bit of a misnomer, as the protocol is actually about
exchanging updates equally, and not particularly about a user needing a
resource like \s-1HTTP\s0 verbs imply.
.SH "Data Model"
.IX Header "Data Model"
Tables for current state of topics, table for updates to topics, tables
to track meta data (Merkle trees).
.PP
Bif is not implementing a distributed database, or at least not in the
classical sense where all nodes need to agree on what the \*(L"current\*(R" or
\&\*(L"latest\*(R" values for objects are, based on some kind of consensus
achieved real-time. What bif does is simply distribute *updates*. The
state of a particular node is the result of the updates it has, and it
doesn't care what the other nodes are doing, or when it will get
missing updates. I.e. there is no consensus. This works because the
users do not need a real-time global view of projects, in the same way
they don't need real-time emails.
.SS "Updates, or Changesets"
.IX Subsection "Updates, or Changesets"
A Bif update can actually be composed of many operations in the
database, but everything relates to a single row in the \f(CW\*(C`updates\*(C'\fR
table. The updates table has an integer primary key which is used for
local operations and foreign key targets. It also has a 40 character
Universally Unique \s-1ID \s0(\s-1UUID\s0).
.PP
The UUIDs of updates (same for UUIDs of topics) are \s-1SHA1\s0 hashes
calculated from the content of the update (or topic). This provides a
builtin checksum mechanism that is useful during synchronisation to
indicate a full and accurate transfer, and potentially simplifies
signing updates in the future. The main purposes of the \s-1UUID\s0 however is
for looking up local IDs when inserting updates with foreign key
requirements.
.PP
Operations happen like this:
.IP "\(bu" 4
create a row in the updates table that identifies the author,
time, timezone, message
.IP "\(bu" 4
add the changes in the *_updates tables for each topic
.IP "\(bu" 4
insert a row into func_merge_updates that calculates the hashes
of everything.
.PP
Updates are immutable, and they can't be easily deleted from
everywhere. For the moment at least. Possibly thinking about updates to
an update...
.SH "Network operations"
.IX Header "Network operations"
.SS "Export/Import"
.IX Subsection "Export/Import"
Basically just copies everything relating to a project from one
repository to another.
.SS "Merkle tree synchronisation"
.IX Subsection "Merkle tree synchronisation"
There is a Merkle tree associated with every project, representing all
of the changes contained therein.
.PP
A sync operation compares the tree from two repositories top-down,
saving the updates missing from each one. The updates are then replayed
in the correct order.
.SH "Author"
.IX Header "Author"
Mark Lawrence <nomad@null.net>
.SH "Copyright & License"
.IX Header "Copyright & License"
Copyright 2013\-2014 Mark Lawrence <nomad@null.net>
.PP
This program is free software; you can redistribute it and/or modify it
under the terms of the \s-1GNU\s0 General Public License as published by the
Free Software Foundation; either version 3 of the License, or (at your
option) any later version.
